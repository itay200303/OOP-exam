שאלה 1: מהו תפקיד המתודה init במחלקת פייתון
תשובה: א. ליצור מופע חדש של המחלקה ולבצע בו אתחול של משתנים

שאלה 2: מה ההבדל המרכזי בין @staticmethod ל־@classmethod בפייתון
תשובה: ב. @classmethod מקבל את המחלקה כפרמטר ראשון (cls), ו־@staticmethod לא מקבל אובייקט בכלל

שאלה 3: מהי מטרת השיטה str במחלקת פייתון
תשובה: ב. להחזיר ייצוג טקסטואלי של האובייקט כשמדפיסים אותו

שאלה 4: מה קורה כאשר מפעילים את האופרטור == על שני מופעים מאותה מחלקה בלי להגדיר את eq
תשובה: ג. ההשוואה תתבצע לפי כתובת הזיכרון של המופעים

שאלה 5: מה נדרש כדי להפוך מחלקה לאיטרטור בפייתון
תשובה: ב. לממש את המתודות iter ו-next

שאלה 6: מהו hash ואיזה תפקיד הוא ממלא
תשובה: ב. מחזיר ערך מספרי ייחודי שמייצג את האובייקט עבור שימוש במבני נתונים כמו dict או set

שאלה 7: מה מאפשרת המתודה add כאשר היא מוגדרת במחלקה
תשובה: ב. שימוש באופרטור + בין מופע של המחלקה לכל אובייקט שתואם את הלוגיקה שבמתודה

שאלה 8: מה יקרה אם נממש eq אך לא נממש hash וננסה להשתמש במופע של המחלקה כ־key במילון (dict)
תשובה: ג. תתקבל שגיאה מסוג TypeError

שאלה 9: מה היתרון המרכזי בשימוש במחלקה מופשטת (abstract base class) בפייתון
תשובה: ג. היא מגדירה ממשק מחייב למחלקות שיורשות ממנה

שאלה 10: מה יקרה אם ננסה ליצור מופע ממחלקה שמוגדרת כ־abstract ויש בה מתודה אחת abstract שלא מומשה
תשובה: ג. תתקבל שגיאה בזמן יצירת מופע

שאלה 11: מהי התוצאה של ניסיון לרשת ממחלקה שמסומנת כ־abstract אך לא לממש את כל המתודות ה־abstract
תשובה: ב. תתקבל שגיאה בזמן יצירת מופע מהמחלקה היורשת

שאלה 12: מה קורה כאשר שני threads ניגשים לאותו משתנה בזיכרון בלי סנכרון מתאים
תשובה: ג. התוצאה עלולה להיות לא צפויה בגלל מצב של race condition

שאלה 13: מה ההבדל בין *args ל־**kwargs בפייתון
תשובה: ג. *args אוסף ארגומנטים לפי מיקום ו־**kwargs אוסף ארגומנטים לפי מפתח

שאלה 14: למה משמשת המתודה hash בפייתון
תשובה: ב. כדי לאפשר שימוש באובייקט כמפתח במילון או כחבר בקבוצת set

שאלה 15: מהי המשמעות של GIL (Global Interpreter Lock) בפייתון
תשובה: ב. מגביל את פייתון כך שרק thread אחד יכול להריץ קוד פייתון בכל רגע נתון

שאלה 16: מה היתרון המרכזי של שימוש ב־logging על פני print בפייתון
תשובה: ג. logging מאפשר רמות דיווח שונות וכתיבה לקובץ או קונסולה

שאלה 17: מה תהיה תוצאת הריצה של הקוד הבא
Python

try:
    result = 10 / 0
except ValueError:
    print("Value error")
finally:
    print("Done")
תשובה: ג. יודפס "Done" ואז תיזרק שגיאת ZeroDivisionError כי אין except מתאים

שאלה 18: הקוד הבא רץ לאט וצורך הרבה זיכרון
Python

def process():
    data = create_big_list()
    doubled = double_values(data)
    return sum(doubled)
מהי הדרך הכי טובה לזהות איזו מהפונקציות create_big_list או double_values אחראית לצריכת זיכרון גבוהה

תשובה: ג. להשתמש ב־memory_profiler עם @profile כדי למדוד שימוש בזיכרון

שאלה 19: מהו מצב של cycle reference בפייתון
תשובה: ב. מצב שבו שני אובייקטים מחזיקים הפניה אחד לשני, כך שלא ניתן לפנות את הזיכרון

שאלה 20: מה תהיה תוצאת הריצה של הקוד הבא מבחינת ניהול זיכרון
class A:
    def __init__(self):
        self.b = None

class B:
    def __init__(self):
        self.a = None

a = A()
b = B()
a.b = b
b.a = a
תשובה: ב. שני האובייקטים יישארו בזיכרון כי יש ביניהם הפניה מעגלית

שאלה 21: יש לך שני קבצים: module_a.py ו־module_b.py, שכל אחד מהם מייבא פונקציה מהשני.
בעת הרצה אתה מקבל שגיאת ImportError או AttributeError בגלל הפניה מעגלית.
מהו פתרון מקובל כדי למנוע הפניה מעגלית ועדיין להשתמש בפונקציה מהמודול השני
תשובה: ב. לשים את ה־import בתוך הפונקציה שזקוקה לו

שאלה 22: מהי המשמעות של Reference Count בפייתון
תשובה: ב. מספר המשתנים שמצביעים על אותו אובייקט בזיכרון

שאלה 23: למה משמשת Weak Reference בפייתון
תשובה: ב. היא מחזיקה הפניה לאובייקט בלי למנוע מה־garbage collector למחוק אותו

שאלה 24: מה היתרון בהגדרת תכונה כ־private עם __name ושימוש ב־getter ו־setter עבורה
תשובה: ג. מאפשר שליטה על גישה, אימות ולוגיקה לפני קריאה או שינוי של הערך

אלה 25: למה נשתמש ב־multiprocessing במקום ב־threading בפייתון
תשובה: ג. כי multiprocessing עוקף את מגבלת ה־GIL ולכן מתאים לעומסים חישוביים
